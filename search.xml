<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[apply和call的用法和区别]]></title>
    <url>%2F2018%2F03%2F24%2Fapply%E5%92%8Ccall%E7%9A%84%E7%94%A8%E6%B3%95%E5%8F%8A%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[每个函数都包含三个非继承而来的方法：apply()方法和call()方法 都是在特定的作用域中调用函数，等于设置函数体内this对象的值，以扩充函数赖以运行的作用域。 Function.prototype.apply() apply() 方法调用一个函数，其具有一个指定的this值，以及作为一个数组（或类似数组的对象）提供的参数。 使用语法： 1func.apply(thisArg, [argsArray]) 参数说明 thisArg 可选的。在 func 函数运行时使用的 this 值。需要注意的是，使用的 this 值并不一定是该函数执行时真正的 this 值，如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动替换为指向全局对象（浏览器中就是window对象），同时值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的包装对象。 argsArray 可选的。一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 func 函数。如果该参数的值为null 或 undefined，则表示不需要传入任何参数。从ECMAScript 5 开始可以使用类数组对象。 返回值调用有指定this值和参数的函数的结果。 例子：123456789101112131415161718192021222324252627window.name = &apos;css&apos;;document.name = &apos;javascript&apos;;var obj = &#123; name: &apos;html5&apos; &#125;;function changeName()&#123; console.log(this.name);&#125;changeName() // css 当前this指向windowchangeName.apply() // css 参数为空，默认指向当前环境的thischangeName.apply(document) // javascript 当前的this指向document对象changeName.apply(obj) // html5 当前的this指向obj对象function beforeWork(work)&#123; this.work = work; this.skills = function () &#123; console.log(this.work) &#125;&#125;function newWork(work)&#123; // beforeWork.call(this, work); beforeWork.apply(this, arguments); // arguments 是一个函数的局部变量。 它可以被用作被调用对象的所有未指定的参数。 &#125;let getWork = new newWork(&apos;web&apos;);getWork.skills(); // web newWork继承了beforeWork，实例化之后，getWork就继承了newWork的属性和方法 Function.prototype.call() call() 方法调用一个函数, 其具有一个指定的this值和分别地提供的参数(参数的列表)。 该方法的作用和 apply() 方法类似，只有一个区别，就是call()方法接受的是若干个参数的列表，而apply()方法接受的是一个包含多个参数的数组或者类数组。 使用语法： 1fun.call(thisArg, arg1, arg2, ...) 参数说明 thisArg 在fun函数运行时指定的this值。需要注意的是，指定的this值并不一定是该函数执行时真正的this值，如果这个函数处于非严格模式下，则指定为null和undefined的this值会自动指向全局对象(浏览器中就是window对象)，同时值为原始值(数字，字符串，布尔值)的this会指向该原始值的自动包装对象。 arg1, arg2, … 指定的参数列表。 返回值返回值是你调用的方法的返回值，若该方法没有返回值，则返回undefined。 例子：123456789101112131415161718192021222324window.name = &apos;css&apos;;document.name = &apos;javascript&apos;;var obj = &#123; name: &apos;html5&apos; &#125;;function changeName()&#123; console.log(this.name);&#125;changeName() // css 当前this指向windowchangeName.call() // css 参数为空，默认指向当前环境的thischangeName.call(document) // javascript 当前的this指向document对象changeName.call(obj) // html5 当前的this指向obj对象function getInfo(work) &#123; console.log(this.name + &quot;,&quot; + this.age + &quot;,&quot; + work)&#125;var Info = &#123; name: &apos;javascript&apos;, age: 18&#125;getInfo.call(Info, &apos;web&apos;); // javascript,18,web 当调用getInfo方法的时候，该方法的this值会绑定到Info对象]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[判断对象为空的几种方式]]></title>
    <url>%2F2018%2F02%2F16%2F%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E4%B8%BA%E7%A9%BA%2F</url>
    <content type="text"><![CDATA[1.将json对象转化为json字符串，再判断该字符串是否为”{}” 12345var data = &#123;&#125;;var b = (JSON.stringify(data) == &quot;&#123;&#125;&quot;);alert(b);//true// 切记不能直接用toString()方法转换toString()方法转换之后是 [object Object] 2.for in 循环判断 12345678var obj = &#123;&#125;;var b = function() &#123; for(var key in obj) &#123; return false; &#125; return true;&#125;alert(b()); //true 3.jquery的isEmptyObject方法此方法是jquery将2方法(for in)进行封装，使用时需要依赖jquery 123var data = &#123;&#125;;var b = $.isEmptyObject(data);alert(b);//true 4.Object.getOwnPropertyNames()方法此方法是使用Object对象的getOwnPropertyNames方法，获取到对象中的属性名，存到一个数组中，返回数组对象，我们可以通过判断数组的length来判断此对象是否为空注意：此方法不兼容ie8，其余浏览器没有测试 123var data = &#123;&#125;;var arr = Object.getOwnPropertyNames(data);alert(arr.length == 0);//true 5.使用ES6的Object.keys()方法与4方法类似，是ES6的新方法, 返回值也是对象中属性名组成的数组 123var data = &#123;&#125;;var arr = Object.keys(data);alert(arr.length == 0);//true]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将类数组转化为数组的几种方式]]></title>
    <url>%2F2018%2F01%2F23%2F%E7%B1%BB%E6%95%B0%E7%BB%84%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[js中将类数组转换为数组的几种方法：最经典的方法，使用Array的slice方法，此方法如果不传参数的话会返回原数组的一个拷贝，因此可以用此方法转换类数组到数组； Array.slice.call() 123var arr = Array.prototype.slice.call(arguments);//等同于var arr = [].slice.call(arguments) Array.from() 是ES6中的方法，用于将类数组转换为数组。 1var arr = Array.from(arguments); 只要有length属性的对象，都可以应用此方法转换成数组。 扩展运算符ES6中的扩展运算符…也能将某些数据结构转换成数组，这种数据结构必须有便利器接口。 1var args = [...arguments]; $.makeArray() jQuery的此方法可以将类数组对象转化为真正的数组 1var arr = $.makeArray(arguments);]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[svg 详解]]></title>
    <url>%2F2018%2F01%2F14%2Fsvg%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[SVG 是使用 XML 来描述二维图形和绘图程序的语言。 SVG 的优势在于： SVG 可被非常多的工具读取和修改（比如记事本） SVG 与 JPEG 和 GIF 图像比起来，尺寸更小，且可压缩性更强。 SVG 是可伸缩的 SVG 图像可在任何的分辨率下被高质量地打印 SVG 可在图像质量不下降的情况下被放大 SVG 图像中的文本是可选的，同时也是可搜索的（很适合制作地图） SVG 可以与 Java 技术一起运行 SVG 是开放的标准 SVG 文件是纯粹的 XML 一个简单的 SVG 文件的例子。SVG 文件必须使用 .svg 后缀来保存： 1234567891011121314151617181920&lt;!-- XML 声明,standalone属性，若为yes表示当前文件独立，这里为no说明不独立，此SVG 文档会引用一个外部文件,如下是 dtd 文件--&gt;&lt;?xml version=&quot;1.0&quot; standalone=&quot;no&quot;?&gt;&lt;!--这里说明引用的dtd文件 位于 “http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd”，该文件归属于W3C，含有所有允许的 SVG 元素。--&gt;&lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt;&lt;!--SVG 代码以 &lt;svg&gt; 元素开始，包括开启标签 &lt;svg&gt; 和关闭标签 &lt;/svg&gt; ，这是根元素。--&gt;&lt;!--width 和 height 属性可设置此 SVG 文档的宽度和高度。version 属性可定义所使用的 SVG 版本，xmlns 属性可定义 SVG 命名空间。--&gt;&lt;svg width=&quot;100%&quot; height=&quot;100%&quot; version=&quot;1.1&quot;xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;&lt;!--&lt;circle&gt; 用来创建一个圆。cx 和 cy 属性定义圆中心的 x 和 y 坐标。如果忽略这两个属性，那么圆点会被设置为 (0, 0)。r 属性定义圆的半径。--&gt;&lt;!--stroke 和 stroke-width 属性控制如何显示形状的轮廓。我们把圆的轮廓设置为 2px 宽，黑边框。--&gt;&lt;!--fill 属性设置形状内的颜色。我们把填充颜色设置为红色。--&gt;&lt;circle cx=&quot;100&quot; cy=&quot;50&quot; r=&quot;40&quot; stroke=&quot;black&quot;stroke-width=&quot;2&quot; fill=&quot;red&quot;/&gt;&lt;!--关闭标签的作用是关闭 SVG 元素和文档本身。所有的开启标签必须有关闭标签！--&gt;&lt;/svg&gt; SVG 文件可通过以下标签嵌入 HTML 文档： embed 、 object 或者 iframe。 使用 embed 标签，embed 标签被所有主流的浏览器支持，并允许使用脚本。但是如果需要创建合法的 XHTML，就不能使用 ，任何 HTML 规范中都没有 标签，所以我个人一般不推荐这种做法。 123&lt;embed src=&quot;rect.svg&quot; width=&quot;300&quot; height=&quot;100&quot;type=&quot;image/svg+xml&quot;pluginspage=&quot;http://www.adobe.com/svg/viewer/install/&quot; /&gt; 注意： HTML 页面中嵌入 SVG 时使用 embed 标签是 Adobe SVG Viewer 推荐的方法，pluginspage 属性指向下载插件的 URL。 使用 object 标签， object 标签是 HTML 4 的标准标签，被所有较新的浏览器支持。它的缺点是不允许使用脚本。我一般也不推荐使用这种方法。 123&lt;object data=&quot;rect.svg&quot; width=&quot;300&quot; height=&quot;100&quot;type=&quot;image/svg+xml&quot;codebase=&quot;http://www.adobe.com/svg/viewer/install/&quot; /&gt; 注意： codebase 属性指向下载插件的 URL。 使用 iframe 标签，iframe 标签可工作在大部分的浏览器中。但是iframe标签一直被诟病有安全性问题，也是慎用。 1&lt;iframe src=&quot;rect.svg&quot; width=&quot;300&quot; height=&quot;100&quot;&gt;&lt;/iframe&gt; 使用 img 标签，img 标签几乎所有的浏览器都支持。而且img标签来引入svg也更合理，因为我们通常使用svg也是用做图形，更符合img的语义化。 1&lt;img src=&quot;svg/iframe.svg&quot; alt=&quot;svg图形&quot; width=&quot;300&quot; height=&quot;100&quot;&gt; 除了以上3种引入外部svg文件的方式使用svg，还可以直接写在html文件中,这种仅仅通过引用 SVG 的命名空间，就能够把 SVG 元素之间添加到 HTML 代码中的方式，也是我个人比较推荐的方式。 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;svg&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;This is an HTML paragraph&lt;/p&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt; &lt;circle cx=&quot;100&quot; cy=&quot;50&quot; r=&quot;40&quot; stroke=&quot;black&quot; stroke-width=&quot;2&quot; fill=&quot;red&quot; /&gt;&lt;/svg&gt;&lt;/body&gt;&lt;/html&gt; 在介绍svg的语法之前，我们先来了解一些svg的css属性，svg的css属性可以像html一样，通过给标签添加style的方式添加，也可以像img的width和height一样，直接声明在标签中 常用的css属性： fill 定义填充背景色 （rgb 值、颜色名或者十六进制值） stroke-width 定义边框的宽度 stroke 定义边框的颜色 fill-opacity 定义填充颜色透明度（合法的范围是：0 - 1） stroke-opacity 定义边框颜色的透明度（合法的范围是：0 - 1） opacity 定义元素的透明值 (范围: 0 到 1) rx 和 ry 定义圆角，类似于css中的border-radius fill-rule属性用于指定使用哪一种方法去判断画布上的某区域是否属于该图形的“内部”（内部区域将被 填充）。fill-rule有三个属性：nonzero / evenodd / inherit，这里详细分析下fill-rule。 nonzero : 这个规则，判断一个点是否在图形内，从该点往任一方向绘制射线到无穷远，然后检查图形的线段和射线相交的点，来确定“内部区域”。从0开始计数，每次路径线段是从左到右穿过射线就加一，从右到左的就减一。通过计算交叉点，如果结果是0，则这个点在路径外部，不然，就是在内部。 evenodd : 这个规则，判断一个点是否在图形内，从该点往任一方向绘制射线到无穷远，然后计算给定图形上线段路径和该射线交叉点的数量。如果这个数是奇数，那么该点在图形内部；如果是偶数，该点在图形外部。 inherit ：这个表示继承，是css大家很常见的一个属性。 - 我们接着说说svg的常用标签: 矩形 rect，rect 标签可用来创建矩形，以及矩形的变种，rect 元素的 width 和 height 属性可定义矩形的高度和宽度，这里就以一个圆角矩形为例： 1234&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt; &lt;rect x=&quot;50&quot; y=&quot;20&quot; rx=&quot;20&quot; ry=&quot;20&quot; width=&quot;150&quot; height=&quot;150&quot; style=&quot;fill:red;stroke:black;stroke-width:5;opacity:0.5&quot;/&gt;&lt;/svg&gt; 圆形 circle， circle 标签可用来创建一个圆，cx和cy属性定义圆点的x和y坐标，r属性定义圆的半径。 1234&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt; &lt;circle cx=&quot;100&quot; cy=&quot;50&quot; r=&quot;40&quot; stroke=&quot;black&quot; stroke-width=&quot;2&quot; fill=&quot;red&quot;/&gt;&lt;/svg&gt; 椭圆 ellipse，ellipse 元素是用来创建一个椭圆，CX，CY分别为圆心点的x轴和y轴坐标，RX，RY分别代表水平方向的半径和垂直方向的半径。 123&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt; &lt;ellipse cx=&quot;200&quot; cy=&quot;50&quot; rx=&quot;100&quot; ry=&quot;50&quot; style=&quot;fill:purple&quot; /&gt;&lt;/svg&gt; 直线 line ，line 元素是用来创建一个直线，x1 定义线条x 轴的开始，y1定义线条y 轴的开始，x2 定义线条 x 轴的结束，y2 定义线条 y 轴的结束。 1234&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt; &lt;line x1=&quot;0&quot; y1=&quot;0&quot; x2=&quot;200&quot; y2=&quot;200&quot; style=&quot;stroke:rgb(255,0,0);stroke-width:2&quot;/&gt;&lt;/svg&gt; 多边形 polygon ，polygon 标签用来创建含有不少于三个边的图形。 多边形是由直线组成，其形状是”封闭”的（所有的线条 连接起来）。 1234&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt; &lt;polygon points=&quot;100,10 40,180 190,60 10,60 160,180&quot; style=&quot;fill:lime;stroke:purple;stroke-width:5;fill-rule:nonzero;&quot; /&gt;&lt;/svg&gt; 曲线 polyline ，polyline 元素是用于创建任何只有直线的形状。 123&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt; &lt;polyline points=&quot;0,40 40,40 40,80 80,80 80,120 120,120 120,160&quot; style=&quot;fill:white;stroke:red;stroke-width:4&quot; /&gt;&lt;/svg&gt; 路径 path ，path 元素是用于定义一个路径。path元素的形状是通过属性d定义的，属性d的值是一个“命令+参数”的序列。大写表示绝对定位，小写表示相对定位。在绘制路径时比较复杂，可以议使用SVG编辑器来创建复杂的图形。 M = moveto，需要两个参数，分别是需要移动到的点的x轴和y轴的坐标。类似于移动画笔的位置。 L = lineto，需要两个参数，分别是一个点的x轴和y轴坐标，L命令将会在当前位置和新位置（L前面画笔所在的点）之间画一条线段。 H = horizontal lineto 绘制平行线， 这个命令只带一个参数，标明在x轴或y轴移动到的位置，因为它们都只在坐标轴的一个方向上移动 V = vertical lineto 绘制垂直线，这个命令只带一个参数，标明在x轴或y轴移动到的位置，因为它们都只在坐标轴的一个方向上移动 C = curveto 三次贝塞尔曲线。(x,y)表示的是曲线的终点，(x1,y1)是起点的控制点，(x2,y2)是终点的控制点。控制点描述的是曲线起始点的斜率，曲线上各个点的斜率，是从起点斜率到终点斜率的渐变过程。 S = smooth curveto 当一个点某一侧的控制点是它另一侧的控制点的对称（以保持斜率不变），可以使用S命令。简写的贝塞尔曲线命令。如果S命令跟在一个C命令或者另一个S命令的后面，它的第一个控制点，就会被假设成前一个控制点的对称点。如果S命令单独使用，前面没有C命令或者另一个S命令，那么它的两个控制点就会被假设为同一个点。 Q = quadratic Bézier curve 二次贝塞尔曲线Q，只需要一个控制点，用来确定起点和终点的曲线斜率。因此它需要两组参数，控制点和终点坐标。 T = smooth quadratic Bézier curveto 与S命令相似，是Q命令的简写命令。与S命令相似，T也会通过前一个控制点，推断出一个新的控制点。这意味着，在你的第一个控制点后面，可以只定义终点，就创建出一个相当复杂的曲线。 A = elliptical Arc 创建SVG曲线的命令。 12A rx ry x-axis-rotation large-arc-flag sweep-flag x ya rx ry x-axis-rotation large-arc-flag sweep-flag dx dy 弧形命令A的前两个参数分别是x轴半径和y轴半径， Z = closepath Z命令会从当前点画一条直线到路径的起点。不区分大小写 123&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt; &lt;path d=&quot;M150 0 L75 200 L225 200 Z&quot; /&gt;&lt;/svg&gt; 文本 text ，text 元素用于定义文本。 textPath 规定文本书写的方向 123456789&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot;&gt; &lt;defs&gt; &lt;path id=&quot;path1&quot; d=&quot;M75,20 a1,1 0 0,0 100,0&quot; /&gt; &lt;/defs&gt; &lt;text x=&quot;10&quot; y=&quot;100&quot; style=&quot;fill:red;&quot;&gt; &lt;textPath xlink:href=&quot;#path1&quot;&gt;I love SVG I love web&lt;/textPath&gt; &lt;/text&gt;&lt;/svg&gt; Stroke 属性，可应用于任何种类的线条，文字和元素就像一个圆的轮廓 stroke 属性定义一条线，文本或元素轮廓颜色 stroke-width 属性定义了一条线，文本或元素轮廓厚度 stroke-linecap 属性定义不同类型的开放路径的终结 stroke-dasharray 属性用于创建虚线 1234567&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt; &lt;g fill=&quot;none&quot;&gt; &lt;path stroke=&quot;red&quot; d=&quot;M5 20 l215 0&quot; /&gt; &lt;path stroke=&quot;blue&quot; d=&quot;M5 40 l215 0&quot; /&gt; &lt;path stroke=&quot;black&quot; d=&quot;M5 60 l215 0&quot; /&gt; &lt;/g&gt;&lt;/svg&gt;]]></content>
      <categories>
        <category>svg</category>
      </categories>
      <tags>
        <tag>svg</tag>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVVM的双向绑定]]></title>
    <url>%2F2018%2F01%2F02%2FMVVM%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[什么是MVVM？MVVM是Model-View-ViewModel的缩写。MVVM最早由微软提出来，它借鉴了桌面应用程序的MVC思想，在前端页面中，把Model用纯JavaScript对象表示，View负责显示，两者做到了最大限度的分离。 把Model和View关联起来的就是ViewModel。ViewModel负责把Model的数据同步到View显示出来，还负责把View的修改同步回Model。MVVM的设计思想：关注Model的变化，让MVVM框架去自动更新DOM的状态，从而把开发者从操作DOM的繁琐步骤中解脱出来！ 理解MVVM的原理之前，我们先来回顾下数据绑定，数据绑定是指页面UI布局与数据源建立连接的过程。 单向数据绑定：指的是我们先把Template(模板)写好，然后把Template(模板)和Model(数据）整合到一起形成HTML代码，然后把这段HTML代码插入到文档流里面,形成完整的View(视图)。如下图所示： 单向数据绑定缺点：HTML代码一旦生成完以后，就没有办法再变了，如果有新的数据来了，那就必须把之前的HTML代码去掉，再重新把新的数据和模板一起整合后插入到文档流中。 双向数据绑定：数据模型（Module）和视图（View）之间的双向绑定。 用户在视图上的修改会自动同步到数据模型中去，同样的，如果数据模型中的值发生了变化，也会立刻同步到视图中去。双向数据绑定的优点是无需进行和单向数据绑定的那些CRUD（Create，Retrieve，Update，Delete）操作，到这里，我们不难发现，MVVM的核心原理就是双向数据绑定。 目前比较流行的MVVM框架就是VueJS ，VueJS 是使用 ES5 提供的 Object.defineProperty() 方法，来实现双向数据绑定的。 我们先来详细了解一下，Object.defineProperty这个方法的使用。MDN给出的解释是： Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。 语法如下： 1Object.defineProperty(obj, prop, descriptor) 参数 obj 要在其上定义属性的对象。 prop 要定义或修改的属性的名称。 descriptor 将被定义或修改的属性描述符。 返回值 被传递给函数的对象。 一个简单例子来看下怎么使用123456var obj = &#123;&#125;Object.defineProperty(obj,&quot;name&quot;,&#123; value:&quot;web&quot;&#125;)console.log(obj.name);//web 前两个参数就不用过多解释了，一看就明白了，我们重点分析一下第三个参数 descriptor 它有以下取值： 1234567891011value：该属性对应的值可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。writable：当且仅当该属性的writable为true时，value才能被赋值运算符改变。默认为 false。configurable：总开关，当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。enumerable：当且仅当该属性的enumerable为true时，该属性才能够出现在对象的枚举属性中。默认为 false。get：一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。该方法返回值被用作属性值。默认为 undefined。set：一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。该方法将接受唯一参数，并将该参数的新值分配给该属性。默认为 undefined。 根据以上的理解，这时候，我们再来看刚才的例子 12345var obj = &#123;&#125;Object.defineProperty(obj,&quot;name&quot;,&#123; value:&quot;web&quot;&#125;)console.log(obj.name);//web 第一次设置的时候，我们只设置了 value，别的并没有设置，但是descriptor这个参数默认帮我们把writable，configurable，enumerable都设为false。也就是说，上面的代码和下面的是等价的，特别注意，这仅仅是第一次设置的时候。 12345678var obj= &#123;&#125;Object.defineProperty(obj,&quot;name&quot;,&#123; value:&quot;web&quot;, writable:false, enumerable:false, configurable:false&#125;)console.log(obj.name);//web 注意我们上面讲的默认值，如果第一次不设置，它会默认帮你设置为false。但是，你第二次再设置他的时候，就会出现不同的情况，我们来逐个分析： configurable 总开关，第一次设置默认为 false 之后，第二次再设置就会报错，比如说： 12345678910var obj= &#123;&#125;Object.defineProperty(obj,&quot;name&quot;,&#123; value:&quot;web&quot;&#125;)console.log(obj.name);//webObject.defineProperty(obj,&quot;name&quot;,&#123; value:&quot;web1&quot;, configurable:true&#125;)console.log(obj.name);//TypeError: Cannot redefine property: name writable 如果设置为fasle，就变成只读了。1234567891011121314151617var new_obj = &#123;&#125;;Object.defineProperty(new_obj,&quot;name&quot;,&#123; value:&quot;web&quot;&#125;)console.log(new_obj.name); //web默认设为只读，接下来，我们尝试修改name属性的值第一种方式：Object.defineProperty(new_obj,&quot;name&quot;,&#123; value:&quot;web1&quot;&#125;)console.log(new_obj.name);//TypeError: Cannot redefine property: name第二种方式：new_obj.name = &quot;javascript&quot;；//没有错误抛出（在严格模式下会抛出，即使之前已经有相同的值）console.log(new_obj.name); //web， 赋值不起作用。 enumerable属性定义了对象的属性是否可以在 for…in 循环和 Object.keys() 中被枚举。 123456789101112131415var obj = &#123;&#125;Object.defineProperty(obj,&quot;age&quot;,&#123; value:18, enumerable:true&#125;)console.log(Object.keys(obj));// 打印[&quot;age&quot;]改为falsevar obj = &#123;&#125;Object.defineProperty(obj,&quot;age&quot;,&#123; value:20, enumerable:false //注意 这里改了&#125;)console.log(Object.keys(obj));// 打印[]for...in 类似，不赘述了 接下来我们来分析下get和set，关于get和set，MDN上有这样一段话： 如果一个描述符同时设置了value,writable,get和set关键字，那么它将被认为是一个数据描述符。如果一个描述符同时有value或writable和get或set关键字，将会产生一个异常。 通俗的说，在 descriptor 中不能同时设置访问器（get 和 set）和 wriable 或 value，否则会错，就是说想用 get 和 set，就不能用 writable 或 value 中的任何一个。 12345678910111213var new_obj = &#123;&#125;Object.defineProperty(new_obj,&quot;num&quot;,&#123; set:function(newValue)&#123; console.log(&quot;开始赋值&quot;); console.log(&quot;你要赋值给我,我的新值是&quot;+ newValue) &#125;, get:function()&#123; console.log(&quot;开始取值&quot;); return 100; //注意这里，我直接返回100 &#125;&#125;)new_obj.num = 10 //开始赋值 你要赋值给我,我的新值是10console.log(new_obj.num) //开始取值 100 注意这里，和我直接返回的值是相同的 简单来说，这个 “num” 属性，赋值或者取值的时候会分别触发 set 和 get 对应的函数。 Vue 就是通过设定对象属性的 setter/getter 方法来监听数据的变化，通过getter进行依赖收集，而每个setter方法就是一个观察者，在数据变更的时候通知订阅者更新视图。 因此需要我们执行以下3个步骤，实现数据的双向绑定： 1、实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者，查看代码，observer.js 2、实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数，查看代码，compile.js 3、实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图，查看代码，watcher.js 实现mvvm的主入口： MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253function MVVM(options) &#123; this.$options = options || &#123;&#125;; var data = this._data = this.$options.data; var me = this; // 数据代理 // 实现 vm.xxx -&gt; vm._data.xxx Object.keys(data).forEach(function(key) &#123; me._proxyData(key); &#125;); this._initComputed(); observe(data, this); this.$compile = new Compile(options.el || document.body, this)&#125;MVVM.prototype = &#123; $watch: function(key, cb, options) &#123; new Watcher(this, key, cb); &#125;, _proxyData: function(key, setter, getter) &#123; var me = this; setter = setter || Object.defineProperty(me, key, &#123; configurable: false, enumerable: true, get: function proxyGetter() &#123; return me._data[key]; &#125;, set: function proxySetter(newVal) &#123; me._data[key] = newVal; &#125; &#125;); &#125;, _initComputed: function() &#123; var me = this; var computed = this.$options.computed; if (typeof computed === &apos;object&apos;) &#123; Object.keys(computed).forEach(function(key) &#123; Object.defineProperty(me, key, &#123; get: typeof computed[key] === &apos;function&apos; ? computed[key] : computed[key].get, set: function() &#123;&#125; &#125;); &#125;); &#125; &#125;&#125;; 查看mvvm入口代码，mvvm.js 最后，在页面里引用如下代码，运行试试效果 1234567891011121314151617181920212223&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;word&quot;&gt; &lt;p&gt;&#123;&#123;word&#125;&#125;&lt;/p&gt; &lt;button v-on:click=&quot;sayHi&quot;&gt;change model&lt;/button&gt;&lt;/div&gt;&lt;script src=&quot;./js/observer.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./js/watcher.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./js/compile.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./js/mvvm.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var vm = new MVVM(&#123; el: &apos;#app&apos;, data: &#123; word: &apos;Hello World!&apos; &#125;, methods: &#123; reverseMessage: function () &#123; this.word = this.word.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125; &#125; &#125;);&lt;/script&gt;]]></content>
      <categories>
        <category>Vue</category>
        <category>MVVM</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6 class详解]]></title>
    <url>%2F2017%2F12%2F25%2Fes6%20class%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[ES6 引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类，事实上，ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。本文通过对比ES5与ES6的用法，来加深对ES6 class的理解。 先来看一个es5通过构造函数来生成实例对象的例子 12345678910function Person(name, age) &#123; this.name = name; this.age = age;&#125;Person.prototype.intro = function () &#123; console.log(&quot;I am &quot;+this.name+&quot;,I am &quot;+this.age)&#125;;var p = new Person(&quot;Tony&quot;, 20); 我们这里先直接来看用es6的class怎么实现同样的功能 12345678910class Person &#123; constructor(name, age) &#123; this.name = name; this.age = age; &#125; intro() &#123; console.log(&quot;I am &quot;+this.name+&quot;,I am &quot;+this.age) &#125;&#125; 上面这段ES6的代码定义了一个“类”，里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。也就是说，ES5 的构造函数Person，对应 ES6 的Person类的构造方法。 Person类除了构造方法，还定义了一个intro方法。注意，定义“类”的方法的时候，不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。 ES6 的类，完全可以看作构造函数的另一种写法，类的数据类型就是函数，类本身就指向构造函数，使用的时候，也是直接对类使用new命令，跟构造函数的用法完全一致。 1234typeof Person // &quot;function&quot;Person === Person.prototype.constructor // truevar p = new Person();p.intro() // I am Tony,I am 20 构造函数的prototype属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面。 123456789101112131415class Person &#123; constructor() &#123; // ... &#125; intro() &#123; // ... &#125;&#125;// 等同于Person.prototype = &#123; constructor() &#123;&#125;, intro() &#123;&#125;&#125;; 由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。Object.assign方法可以很方便地一次向类添加多个方法。 12345678910class Person &#123; constructor()&#123; // ... &#125;&#125;Object.assign(Person.prototype, &#123; intro()&#123;&#125;, show()&#123;&#125;&#125;); prototype对象的constructor属性，直接指向“类”的本身,类的内部所有定义的方法，都是不可枚举的，而ES5里边构造函数的prototype绑定的方法是可枚举的。 1234567891011121314151617181920212223242526272829class Person &#123; constructor(x, y) &#123; // ... &#125; intro() &#123; // ... &#125;&#125;Object.keys(Person.prototype)// []Object.getOwnPropertyNames(Person.prototype)// [&quot;constructor&quot;,&quot;intro&quot;]ES5 写法var Person = function (x, y) &#123; // ...&#125;;Person.prototype.intro = function() &#123; // ...&#125;;Object.keys(Person.prototype)// [&quot;intro&quot;]Object.getOwnPropertyNames(Person.prototype)// [&quot;constructor&quot;,&quot;intro&quot;] 类的属性名，可以采用表达式。如下，类的方法名getAge，是从表达式得到的。 1234567891011let methodName = &apos;getAge&apos;;class Person &#123; constructor(length) &#123; // ... &#125; [methodName]() &#123; // ... &#125;&#125; 与函数一样，类也可以使用表达式的形式定义。 12345const Person = class P &#123; getClassName() &#123; return p.name; &#125;&#125;; 上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是Person而不是P，P只在 Class 的内部可用，指代当前类。类的内部没用到的话，可以省略。因为可以使用表达式，可以试着写一个立即执行的class，如下，Show就是一个立即执行的类。 1234567891011let Show = new class &#123; constructor(name) &#123; this.name = name; &#125; sayName() &#123; console.log(this.name); &#125;&#125;(&apos;张三&apos;);Show.sayName(); // &quot;张三&quot; 类不存在变量提升（hoist），这一点与 ES5 完全不同。ES6 不会把类的声明提升到代码头部。所以，必须先声明，在调用，这样做与继承有关，必须保证子类在父类之后定义。类可以通过extends关键字实现继承。子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。子类实例的构建，是基于对父类实例加工，只有super方法才能返回父类实例。 1234new Show() // ReferenceErrorclass Show&#123; &#125; 类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。静态方法可以与非静态方法重名,并且父类的静态方法，可以被子类继承。 123456789101112131415161718192021222324class Show &#123; constructor(x, y)&#123; this.x = x; this.y = y; &#125; static print() &#123; return &apos;hello&apos;; &#125;&#125;Show.print() // &apos;hello&apos; var foo = new Show();foo.print() // TypeError: foo.print is not a functionclass Start extends Show &#123; constructor(x, y, color) &#123; super(x, y); // 调用父类的constructor(x, y) this.color = color; &#125;&#125;Start.print() // &apos;hello&apos; Object.getPrototypeOf方法可以用来从子类上获取父类。 1Object.getPrototypeOf(Start) === Show // true super这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。 第一种情况，super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。子类构造函数之中的super()，代表调用父类的构造函数。这是必须的，否则 JavaScript引擎会报错。super虽然代表了父类的构造函数，但是返回的是子类的实例，即super内部的this指的是子类，因此super()在这里相当于 1parent.prototype.constructor.call(this)。 特别注意，作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错。 第二种情况，super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。 123456789101112131415class Show &#123; print() &#123; return 2; &#125;&#125;class Start extends Show &#123; constructor() &#123; super(); console.log(super.print()); // 2 &#125;&#125;let b = new Start(); 上面代码中，子类Start当中的super.print()，就是将super当作一个对象使用。这时，super在普通方法之中，指向Show.prototype，所以super.print()Show.prototype.print()。但是需要注意，由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。反之，如果属性定义在父类的原型对象上，super就可以取到。 ES6 规定，通过super调用父类的方法时，方法内部的this指向子类。由于this指向子类，所以如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性。 如果super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象。也就是说super在静态方法之中指向父类，在普通方法之中指向父类的原型对象。 除了以上之外，想了解更多class的特性，请参考阮一峰老师的es6入门class教程]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建 Node.js 环境]]></title>
    <url>%2F2017%2F11%2F23%2F%E4%BA%91%E4%B8%BB%E6%9C%BA%E6%90%AD%E5%BB%BAnodejs%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[1. 安装 Node.js 环境 Node.js 是运行在服务端的 JavaScript, 是基于 Chrome JavaScript V8 引擎建立的平台。 下载并安装 Node.js 1wget https://nodejs.org/dist/v8.7.0/node-v8.7.0-linux-x64.tar.xz 下载完成后, 将其解压 1tar xvJf node-v8.7.0-linux-x64.tar.xz 将解压的 Node.js 目录移动到 /usr/local 目录下 1mv node-v8.7.0-linux-x64 /usr/local/node-v8 配置 node 软链接到 /bin 目录 1ln -s /usr/local/node-v8/bin/node /bin/node 2. 配置和使用npm 配置 npm npm 是 Node.js 的包管理和分发工具。它可以让 Node.js 开发者能够更加轻松的共享代码和共用代码片段 下载 node 的压缩包中已经包含了 npm , 我们只需要将其软链接到 bin 目录下即可 1ln -s /usr/local/node-v8/bin/npm /bin/npm 配置环境变量 将 /usr/local/node-v6/bin 目录添加到 $PATH 环境变量中可以方便地使用通过 npm 全局安装的第三方工具 1echo &apos;export PATH=/usr/local/node-v8/bin:$PATH&apos; &gt;&gt; /etc/profile 生效环境变量 1source /etc/profile 使用 npm 通过 npm 安装进程管理模块 forever 1npm install forever -g 到此nodejs环境已经搭建完成]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用hexo搭建自己的博客]]></title>
    <url>%2F2017%2F08%2F26%2F%E5%88%A9%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[介绍 hexo是一款基于Node.js的静态博客框架,方便、快捷。并且有丰富的主题可供选择，是大多数开发者的首选。 环境配置 安装node.js 安装git，注册github账户nodejs可以到nodejs官网下载相应的版本，安装也很简单这里不再多说，安装完成后，打开命令行，执行 1node -v 出现正确的安装版本，即安装成功。由于nodejs自带的包管理工具npm在国内安装比较慢，建议大家将包地址换为国内淘宝镜像源。执行如下命令： 1npm config set registry https://registry.npm.taobao.org git是目前比较流行的版本控制系统，这里推荐廖雪峰老师的git教程，大家可以安装学习，github的安装注册更不用我再废话了，我们这里主要是利用github提供的gh-pages服务把自己的博客托管到github上去。 开始搭建1. 利用npm，来全局安装hexo和hexo脚手架工具,hexo只需要全局安装一次，以后就可以在项目里使用了 12npm install -g hexonpm install -g hexo-cli 2. 开始创建 1hexo init blogs //初始化，会在本地生成一个blogs目录 3. 本地浏览 1234cd blogs //来到新建的目录npm install //安装依赖hexo g //(hexo generate的简写)编译输出静态文件hexo s //(hexo server的简写)开启本地服务 浏览器输入http://localhost:4000，如果你本地的4000端口被占用，可能会报错，执行如下命令，来改端口。1hexo server -p 5000 //5000可以改为任意你想设定的端口 4. 建立github连接 在github上新建一个Repository，命名必须为【your_user_name.github.io】，固定写法，大小写都不能错，比如你的用户名是webblogs，这里新建的Repository命名必须为 webblogs.github.io 在刚才新建的blogs目录下，找到配置文件：_config.yml，进行修改 1234deploy: type: git repo: https://github.com/liutaochange/liutaochange.github.io.git branch: master 注意把这里的liutaochange换成你自己的用户名 5. 开始部署 1hexo d //(hexo deploy 的简写)部署 如果这里有报错 1ERROR Deployer not found: git 或者 ERROR Deployer not found: github 执行命令 1npm install hexo-deployer-git --save //安装hexo 的 git插件 出现 【Deploy done: github】表示部署成功 打开 https://liutaochange.github.io 就可以访问 关于主题 Hexo提供了官网的主题, 初始化Hexo 时也会自动生成一个主题, Hexo还支持个性定制主题, 也可以根据自己的喜好在themes里选择。 启用主题 下载主题到你blogs目录下的themes文件夹下，打开配置文件找到1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: yilia //这里改为你需要的主题 验证主题12hexo clean //来清除 Hexo 的缓存hexo s –debug //debug模式，本地调试 启动正常后，你的主题已经修改成功。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
